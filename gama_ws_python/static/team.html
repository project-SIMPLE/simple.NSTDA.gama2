<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Team | GAMA Control</title>
  <link href="/static/vendor/bootstrap.min.css" rel="stylesheet"/>
  <style>
    body { background:#f5f7fa; }
    .card { border-radius:1rem; box-shadow:0 2px 8px rgba(0,0,0,.08); }

    /* Header grid: ‡πÉ‡∏´‡πâ‡∏Ñ‡∏≠‡∏•‡∏±‡∏°‡∏ô‡πå‡∏ä‡∏∑‡πà‡∏≠‡∏ó‡∏µ‡∏°‡∏Å‡∏ß‡πâ‡∏≤‡∏á‡πÄ‡∏ó‡πà‡∏≤‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏° */
    .header-grid { display:grid; grid-template-columns:1fr; gap:.75rem; }
    @media (min-width:768px){
      .header-grid{
        grid-template-columns: max-content auto; /* ‡∏û‡∏≠‡∏î‡∏µ‡∏Å‡∏±‡∏ö‡πÄ‡∏ô‡∏∑‡πâ‡∏≠‡∏´‡∏≤ */
        align-items:center; column-gap:1rem;
      }
    }

    /* Team box: ‡∏´‡∏î‡∏û‡∏≠‡∏î‡∏µ‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏° */
    #teamFrame{
      display:inline-flex; align-items:center;
      border:3px solid; background:#fff; border-radius:1rem;
      box-shadow:0 2px 10px rgba(0,0,0,.06);
      padding:.45rem .9rem;
      width:fit-content; max-width:100%;
    }
    .team-name{
      margin:0; font-size:clamp(1.25rem,6vw,2rem); line-height:1.1;
      white-space:nowrap; overflow:hidden; text-overflow:ellipsis;
    }

    .status-box{ display:inline-flex; align-items:center; gap:.5rem; flex-wrap:wrap; }
    @media (max-width:767.98px){
      .status-box{ display:flex; flex-direction:column; align-items:stretch; gap:.5rem; }
      #reconn{ width:100%; }
    }

    .actions{ display:grid; gap:.5rem; }
    @media (min-width:768px){ .actions{ display:flex; gap:.5rem; flex-wrap:wrap; } .actions .btn{ min-width:14rem; } }
    .btn .icon{ font-size:1.15em; line-height:1; margin-right:.35rem; }
    .coins-line{ display:flex; align-items:center; gap:.5rem; }
    #scoreChart{ width:100%; height:260px; }
    .meta-line{ display:flex; justify-content:space-between; align-items:center; gap:.5rem; }
    .meta-line small{ color:#6b7280; }
  </style>
  <script src="/static/vendor/echarts.min.js"></script>
</head>
<body>
<div class="container py-4">
  <div class="card p-4">

    <!-- Header -->
    <div class="header-grid mb-2">
      <div id="teamFrame">
        <h3 id="teamTitle" class="team-name">Team</h3>
      </div>
      <div class="status-box">
        <span class="fw-semibold">Status:</span>
        <span id="badge" class="badge text-bg-secondary">Disconnected</span>
        <button id="reconn" class="btn btn-outline-primary">Re-connect</button>
      </div>
    </div>

    <hr/>

    <!-- Coins -->
    <div class="coins-line mb-3">
      <span class="fw-semibold">Coins:</span>
      <span id="coins" class="badge text-bg-dark">0</span>
    </div>

    <!-- Actions -->
    <div class="actions mb-2">
      <button class="btn btn-danger"  id="btn_fire"><span class="icon">üî•</span>Reset Fire (cost 3)</button>
      <button class="btn btn-warning" id="btn_alien"><span class="icon">üëΩ</span>Reset Alien (cost 2)</button>
      <button class="btn btn-success" id="btn_grass"><span class="icon">üåø</span>Reset Grass (cost 1)</button>
    </div>

    <!-- Scores Chart -->
    <div class="meta-line">
      <div class="fw-semibold">Scores</div>
      <small id="lastUpdate">Last update: ‚Äì</small>
    </div>
    <div id="scoreChart" class="mt-2"></div>

  </div>
</div>

<!-- Confirm Modal -->
<div class="modal fade" id="confirmModal" tabindex="-1" aria-hidden="true">
  <div class="modal-dialog modal-dialog-centered">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title">Confirm reset</h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
      </div>
      <div class="modal-body">
        <p class="mb-1">Threat: <strong id="cfThreat">-</strong></p>
        <p class="mb-1">Cost: <span class="badge text-bg-dark" id="cfCost">0</span></p>
        <p class="text-muted small mb-0">Your coins: <span id="cfCoins">0</span></p>
      </div>
      <div class="modal-footer">
        <button type="button" class="btn btn-outline-secondary" data-bs-dismiss="modal">Cancel</button>
        <button type="button" class="btn btn-primary" id="cfConfirmBtn">Confirm</button>
      </div>
    </div>
  </div>
</div>

<div class="toast-container position-fixed bottom-0 end-0 p-3" id="toasts"></div>
<script src="/static/vendor/bootstrap.bundle.min.js"></script>

<script>
/* -------- Team -------- */
const qp   = new URLSearchParams(location.search);
const TEAM = qp.get("team") || "Unknown";
const TEAMS = ['Blue','Red','Green','Yellow','Black','White'];
document.getElementById("teamTitle").textContent = `Team ${TEAM}`;
document.title = `Team ${TEAM} | GAMA Control`; // ‡∏ï‡∏±‡πâ‡∏á title ‡∏ï‡∏≤‡∏°‡∏ó‡∏µ‡∏°

/* -------- Buttons & Costs -------- */
const btnFire  = document.getElementById("btn_fire");
const btnAlien = document.getElementById("btn_alien");
const btnGrass = document.getElementById("btn_grass");
const reconnBtn= document.getElementById("reconn");
const badge    = document.getElementById("badge");
const coinsEl  = document.getElementById("coins");
const lastUpdateEl = document.getElementById("lastUpdate");
const COST     = { Fire:3, Alien:2, Grass:1 };

/* Team frame color */
const TEAM_COLOR = { Blue:"#1d4ed8", Red:"#dc2626", Green:"#16a34a", Yellow:"#eab308", Black:"#111827", White:"#9ca3af" };
document.getElementById("teamFrame").style.borderColor = TEAM_COLOR[TEAM] || "#6c757d";

/* -------- Toasts -------- */
const toasts = document.getElementById("toasts");
function showToast(msg, variant="primary") {
  const el = document.createElement("div");
  el.className = `toast align-items-center text-bg-${variant} border-0`;
  el.innerHTML = `<div class="d-flex"><div class="toast-body">${msg}</div><button type="button" class="btn-close btn-close-white me-2 m-auto" data-bs-dismiss="toast"></button></div>`;
  toasts.appendChild(el);
  const t = new bootstrap.Toast(el, { delay: 2200 }); t.show();
  el.addEventListener("hidden.bs.toast", () => el.remove());
}

/* -------- Utils -------- */
function nowStr(){ const d=new Date(); const p=n=>String(n).padStart(2,'0'); return `${p(d.getHours())}:${p(d.getMinutes())}:${p(d.getSeconds())}`; }
function setLastUpdate(source){ lastUpdateEl.textContent = `Last update: ${nowStr()} (${source})`; }

/* -------- Coins (server-authoritative) -------- */
let coinsLoaded = false;
let currentCoins = 0;
function setCoins(val){ currentCoins = Math.max(0, val|0); coinsEl.textContent = String(currentCoins); updateActionButtons(); }
async function fetchCoins(){
  const res = await fetch(`/api/coins/${encodeURIComponent(TEAM)}`);
  if (!res.ok) throw new Error(`HTTP ${res.status}`);
  const data = await res.json();
  setCoins(data.coins ?? 0); coinsLoaded = true;
}
async function decrementCoins(cost, action){
  const res = await fetch("/api/coins/decrement", {
    method: "POST", headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ team: TEAM, cost, action })
  });
  if (!res.ok) throw new Error(`HTTP ${res.status}`);
  const data = await res.json(); if (typeof data.coins === "number") setCoins(data.coins); return data;
}
async function refundCoins(amount){
  try{
    const res = await fetch("/api/coins/refund", {
      method: "POST", headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ team: TEAM, amount })
    });
    if (!res.ok) throw new Error(`HTTP ${res.status}`);
    const data = await res.json(); if (typeof data.coins === "number") setCoins(data.coins); return data;
  }catch{ showToast("Refund failed, please sync.", "warning"); return null; }
}

/* -------- ECharts -------- */
const BAR_LABELS = ['Qu','Sa','Ma','Pho','De','Di','Os','Phy','Ca','Gm'];
let chart = null;
function ensureChart(){
  if (chart) return;
  chart = echarts.init(document.getElementById('scoreChart'));
  window.addEventListener('resize', () => chart && chart.resize());
  chart.setOption({
    animation:true, animationDuration:300, animationEasing:'cubicOut',
    animationDurationUpdate:500, animationEasingUpdate:'cubicOut',
    grid:{ left:40, right:12, top:20, bottom:35 },
    tooltip:{ trigger:'item', formatter:p => `${p.name}: ${p.value}` },
    xAxis:{ type:'category', data:BAR_LABELS, axisTick:{ alignWithLabel:true }, axisLabel:{ rotate:90 } },
    yAxis:{ type:'value', min:0, max:10, interval:1 },
    series:[{ type:'bar', data:new Array(BAR_LABELS.length).fill(0),
      itemStyle:{ color:(TEAM_COLOR[TEAM] || '#6c757d') }, universalTransition:true }]
  });
}
function normalizeScores(arr){
  const out = new Array(10).fill(0);
  for (let i=0;i<10;i++){ const v=Number(arr?.[i]); const n=Number.isFinite(v)?Math.max(0,Math.min(10,Math.round(v))):0; out[i]=n; }
  return out;
}
function updateChart(scores, source="WS"){ ensureChart(); chart.setOption({ series:[{ data: normalizeScores(scores) }] }); setLastUpdate(source); }

/* -------- Scores: initial load -------- */
async function fetchScores(){
  const res = await fetch(`/api/scores/${encodeURIComponent(TEAM)}`);
  if (!res.ok) throw new Error(`HTTP ${res.status}`);
  const data = await res.json(); updateChart(data.scores || [], "Fetch");
}

/* -------- parse KV (fallback) -------- */
// {type=score_update, team=Blue, scores=[10,10,10,10,10,10,10,10,10,10]}
function parseGamaKVMessage(s){
  if (typeof s !== "string") return null;
  const t=s.trim(); if (!t.includes("=")) return null;
  const mTeam=/team\s*=\s*"?([A-Za-z]+)"?/i.exec(t); const team=mTeam?mTeam[1]:null;
  const mScores=/scores?\s*=\s*\[([^\]]*)\]/i.exec(t); let scores=[];
  if (mScores && mScores[1]) scores=mScores[1].split(",").map(x=>parseFloat(x.trim())).filter(n=>!Number.isNaN(n));
  const mType=/type\s*=\s*"?(scores?_update)"?/i.exec(t); const typ=mType?mType[1]:"score_update";
  if (!team || !scores.length) return null; return { type: typ, team, scores };
}

/* -------- WebSocket (+ auto-reconnect) -------- */
let sock=null, bridgeReady=false, gamaReady=false;
const READY={ CONNECTING:0, OPEN:1, CLOSING:2, CLOSED:3 };
const STATUS={ DISCONNECTED:"Disconnected", CONNECTING:"Connecting", WAITING:"Waiting GAMA", CONNECTED:"Connected" };
function setBadge(text, cls){ badge.textContent=text; badge.className="badge text-bg-"+cls; }
function isSockOpen(){ return sock && sock.readyState===READY.OPEN; }

/* Backoff */
let wsRetry=0, wsTimer=null;
const WS_BACKOFF=[800,1500,3000,5000,8000];
function resetReconnect(){ if(wsTimer){ clearTimeout(wsTimer); wsTimer=null; } wsRetry=0; }
function scheduleReconnect(){ if(wsTimer) return; const d=WS_BACKOFF[Math.min(wsRetry,WS_BACKOFF.length-1)]; wsTimer=setTimeout(()=>{ wsTimer=null; wsRetry++; connectWS(); }, d); }
function hardReconnect(){
  resetReconnect();
  try{ if(sock){ sock.onopen=sock.onclose=sock.onerror=sock.onmessage=null; sock.close(); } }catch{}
  sock=null; connectWS();
}

/* Buttons enable/disable */
function updateActionButtons(){
  const canSend = gamaReady && isSockOpen();
  const validTeam = TEAMS.includes(TEAM);
  const connecting = sock && sock.readyState===READY.CONNECTING;
  const setBtnState=(btn, baseClass, cost)=>{
    const enough=currentCoins>=cost; const on=canSend && coinsLoaded && enough && validTeam;
    btn.disabled=!on; btn.classList.remove("btn-secondary","btn-danger","btn-warning","btn-success"); btn.classList.add(on?baseClass:"btn-secondary");
  };
  setBtnState(btnFire,"btn-danger",COST.Fire);
  setBtnState(btnAlien,"btn-warning",COST.Alien);
  setBtnState(btnGrass,"btn-success",COST.Grass);
  // ‡πÉ‡∏´‡πâ‡∏Å‡∏î‡πÑ‡∏î‡πâ‡πÄ‡∏™‡∏°‡∏≠ ‡∏¢‡∏Å‡πÄ‡∏ß‡πâ‡∏ô‡∏Å‡∏≥‡∏•‡∏±‡∏á CONNECTING (‡∏Å‡∏±‡∏ô‡∏Å‡∏î‡∏£‡∏±‡∏ß)
  reconnBtn.disabled = !!connecting;
}
function refreshUI(){
  const connecting = sock && sock.readyState===READY.CONNECTING;
  if (connecting) setBadge(STATUS.CONNECTING,"info");
  else if (!bridgeReady) setBadge(STATUS.DISCONNECTED,"secondary");
  else if (!gamaReady) setBadge(STATUS.WAITING,"warning");
  else setBadge(STATUS.CONNECTED,"success");
  updateActionButtons();
}

/* WebSocket connect */
function connectWS(){
  if (sock && (sock.readyState===READY.CONNECTING || sock.readyState===READY.OPEN)) return;
  if (sock && (sock.readyState===READY.CLOSING || sock.readyState===READY.CLOSED)) { try{ sock.close(); }catch{} sock=null; }

  bridgeReady=false; gamaReady=false; refreshUI();
  showToast("Connecting to bridge...", "secondary");

  const scheme = location.protocol==="https:" ? "wss://" : "ws://";
  const url = scheme + location.host + "/ws";
  sock = new WebSocket(url);

  sock.onopen = () => { bridgeReady=true; gamaReady=false; resetReconnect(); showToast("Bridge connected. Waiting for GAMA...", "info"); refreshUI(); };
  sock.onclose = () => { bridgeReady=false; gamaReady=false; showToast("Disconnected ‚Äî retrying...", "secondary"); refreshUI(); scheduleReconnect(); };
  sock.onerror = () => { bridgeReady=false; gamaReady=false; showToast("Connection error ‚Äî retrying...", "danger"); refreshUI(); scheduleReconnect(); };
  sock.onmessage = (e) => {
    let obj=null; try{ obj=JSON.parse(e.data); }catch{} if(!obj) obj=parseGamaKVMessage(e.data);
    if (obj && obj.type==="coins_update"){ if (obj.team===TEAM && typeof obj.coins==="number") setCoins(obj.coins); return; }
    if (obj && (obj.type==="scores_update" || obj.type==="score_update")){
      const arr=Array.isArray(obj.scores)?obj.scores:(Array.isArray(obj.score)?obj.score:null);
      if (obj.team===TEAM && Array.isArray(arr)) updateChart(arr,"WS"); return;
    }
    try{
      if (obj?.error==="gama_unreachable"){ gamaReady=false; showToast("GAMA not reachable. Retrying...", "warning"); refreshUI(); return; }
      if (obj?.info==="gama_connected"){ gamaReady=true; showToast("Bridge connected to GAMA", "success"); refreshUI(); return; }
    }catch{}
  };
}
document.addEventListener("visibilitychange", () => { if (document.visibilityState==="visible" && !isSockOpen()) scheduleReconnect(); });
window.addEventListener("pageshow", (e) => { if (e.persisted) hardReconnect(); });
window.addEventListener("online",  () => { showToast("Back online ‚Äî reconnecting...","success"); hardReconnect(); });
window.addEventListener("offline", () => { showToast("You are offline","warning"); });

/* -------- Confirm modal & actions -------- */
const confirmModalEl=document.getElementById('confirmModal');
const confirmModal=new bootstrap.Modal(confirmModalEl);
const cfThreatEl=document.getElementById('cfThreat');
const cfCostEl=document.getElementById('cfCost');
const cfCoinsEl=document.getElementById('cfCoins');
const cfConfirmBtn=document.getElementById('cfConfirmBtn');
let pending=null;
function openConfirm(threat,cost){ pending={threat,cost}; cfThreatEl.textContent=threat; cfCostEl.textContent=String(cost); cfCoinsEl.textContent=String(currentCoins); confirmModal.show(); }
function sendReset(threat){
  if (!gamaReady || !isSockOpen()) { showToast("Not connected to GAMA","warning"); return false; }
  const msg=`type=RemoveThreat;team=${TEAM};threat=${threat}`;
  try{ sock.send(msg); showToast(`Sent reset "${threat}"`,"info"); return true; }catch{ showToast("Failed to send","danger"); return false; }
}
cfConfirmBtn.onclick=async()=>{ if(!pending) return; const {threat,cost}=pending;
  let dec; try{ dec=await decrementCoins(cost,threat); }catch{ showToast("Failed to update coins on server.","danger"); return; }
  if(!dec?.ok){ const serverCoins=typeof dec?.coins==="number"?dec.coins:currentCoins; showToast(`Not enough coins. You have ${serverCoins}.`,"warning"); return; }
  const sent=sendReset(threat); if(!sent){ await refundCoins(cost); showToast("Action failed. Refunded coins.","warning"); return; }
  showToast(`Coins deducted (-${cost}). Remaining: ${currentCoins}`,"success"); confirmModal.hide(); pending=null;
};

/* Hooks */
btnFire.onclick=()=>openConfirm("Fire",COST.Fire);
btnAlien.onclick=()=>openConfirm("Aliens",COST.Alien);
btnGrass.onclick=()=>openConfirm("Grasses",COST.Grass);
reconnBtn.onclick=()=>{ hardReconnect(); };

/* -------- Init -------- */
async function fullSync(){
  if (!TEAMS.includes(TEAM)){ showToast("Unknown team. Controls disabled.","warning"); updateActionButtons(); return; }
  await Promise.allSettled([fetchCoins(), fetchScores()]);
  setLastUpdate("Fetch"); updateActionButtons();
}
(async function init(){
  ensureChart();
  await fullSync();
  connectWS();
  setTimeout(()=>{ if(!isSockOpen()) scheduleReconnect(); }, 1000);
})();
</script>
</body>
</html>